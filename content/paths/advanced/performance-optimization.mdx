import ConceptExplainer from '@/components/learning/ConceptExplainer';
import CodePlayground from '@/components/interactive/CodePlayground';

export const meta = {
  title: 'Performance Optimization',
  description: 'Optimizing SuiteScript and SPA performance',
  duration: '1.5 hours',
};

# Performance Optimization

## Introduction

Learn advanced techniques to optimize NetSuite customizations for maximum performance and efficiency.

<ConceptExplainer
  concept={{
    id: 'netsuite-performance',
    title: 'NetSuite Performance Optimization',
    category: 'performance',
    simpleExplanation:
      'Performance optimization is like tuning a race car - making small adjustments that add up to big speed improvements. In NetSuite, this means writing efficient code that uses fewer resources and runs faster.',
    technicalDetails:
      'Optimization techniques:\n- Minimize governance unit usage\n- Batch operations\n- Cache frequently accessed data\n- Use Map/Reduce for large datasets\n- Optimize search filters\n- Reduce HTTP requests\n- Bundle JavaScript files',
    visualType: 'diagram',
    commonMistakes: [
      'Loading entire records when only need few fields',
      'Running searches in loops',
      'Not caching lookup data',
      'Synchronous processing of large datasets',
    ],
    realWorldExample:
      'Instead of loading 1000 customer records one-by-one (slow), use a single search to get all 1000 at once, then process them in parallel with Map/Reduce (fast).',
  }}
/>

## Governance Optimization

### Before (Inefficient)

<CodePlayground
  initialCode={`// âŒ Bad: Loading full record for each item
for (var i = 0; i < 1000; i++) {
    var customer = record.load({
        type: record.Type.CUSTOMER,
        id: customerIds[i]
    });
    var email = customer.getValue('email');
    // Uses 5-10 units per iteration = 5000-10000 units total!
}`}
  language="typescript"
  title="Inefficient Approach"
/>

### After (Optimized)

<CodePlayground
  initialCode={`// âœ… Good: Use search to get only needed fields
var customerSearch = search.create({
    type: search.Type.CUSTOMER,
    filters: [
        ['internalid', 'anyof', customerIds]
    ],
    columns: ['email']
});

var results = customerSearch.run().getRange({
    start: 0,
    end: 1000
});
// Uses ~10 units total - 500x more efficient!`}
  language="typescript"
  title="Optimized Approach"
/>

## Search Optimization

### Efficient Filters

- Use internal IDs when possible
- Index custom fields used in filters
- Limit result columns to only what's needed
- Use summary types to aggregate

### Pagination

<CodePlayground
  initialCode={`// Process large result sets in chunks
var pageSize = 1000;
var start = 0;

do {
    var results = mySearch.run().getRange({
        start: start,
        end: start + pageSize
    });

    results.forEach(function(result) {
        // Process result
    });

    start += pageSize;
} while (results.length === pageSize);`}
  language="typescript"
  title="Efficient Pagination"
/>

## Caching Strategies

### In-Memory Cache

```javascript
var cache = {};

function getCustomerEmail(customerId) {
    if (cache[customerId]) {
        return cache[customerId];
    }

    var customer = record.load({
        type: record.Type.CUSTOMER,
        id: customerId
    });

    cache[customerId] = customer.getValue('email');
    return cache[customerId];
}
```

### N/cache Module

```javascript
var cache = require('N/cache');

var myCache = cache.getCache({
    name: 'customerData',
    scope: cache.Scope.PUBLIC
});

// Store
myCache.put({
    key: 'customer_123',
    value: JSON.stringify(customerData),
    ttl: 3600 // 1 hour
});

// Retrieve
var cached = myCache.get({ key: 'customer_123' });
```

## Map/Reduce for Scale

Use Map/Reduce for processing large datasets:

<CodePlayground
  initialCode={`/**
 * @NApiVersion 2.1
 * @NScriptType MapReduceScript
 */
define(['N/search', 'N/record'], (search, record) => {

    function getInputData() {
        // Return search with data to process
        return search.create({
            type: search.Type.CUSTOMER,
            filters: [['status', 'anyof', '13']] // Active customers
        });
    }

    function map(context) {
        var customer = JSON.parse(context.value);

        // Process customer
        var updates = processCustomer(customer);

        context.write({
            key: customer.id,
            value: updates
        });
    }

    function reduce(context) {
        var customerId = context.key;
        var updates = JSON.parse(context.values[0]);

        // Apply updates
        record.submitFields({
            type: record.Type.CUSTOMER,
            id: customerId,
            values: updates
        });
    }

    function summarize(context) {
        log.audit('Summary', {
            totalRecords: context.inputSummary.recordsProcessed,
            duration: context.inputSummary.seconds
        });
    }

    return {
        getInputData,
        map,
        reduce,
        summarize
    };
});`}
  language="typescript"
  title="Map/Reduce Script"
/>

## SPA Performance

### Code Splitting

Load only what's needed:

```javascript
// Lazy load heavy modules
routes: {
    'reports': function() {
        require(['Reports.View'], function(ReportsView) {
            new ReportsView().render();
        });
    }
}
```

### Minimize Bundle Size

- Remove unused code
- Minify JavaScript
- Compress images
- Use CDN for libraries

### Virtual Scrolling

For long lists, render only visible items:

```javascript
var VirtualList = Backbone.View.extend({
    initialize: function() {
        this.visibleItems = 50;
        this.scrollTop = 0;
    },

    render: function() {
        var startIndex = Math.floor(this.scrollTop / this.itemHeight);
        var endIndex = startIndex + this.visibleItems;

        var visibleData = this.collection.slice(startIndex, endIndex);

        // Render only visible items
        this.renderItems(visibleData);
    }
});
```

## Database Query Optimization

### Use SuiteQL

For complex queries, SuiteQL can be more efficient:

```javascript
var query = require('N/query');

var results = query.runSuiteQL({
    query: `
        SELECT
            c.companyname,
            SUM(t.amount) as total_sales
        FROM
            customer c
            JOIN transaction t ON c.id = t.customer
        WHERE
            t.trandate >= '2024-01-01'
        GROUP BY
            c.companyname
        ORDER BY
            total_sales DESC
        LIMIT 100
    `
}).asMappedResults();
```

## Profiling and Monitoring

### Script Execution Log

Monitor performance in real-time:
1. Navigate to **Governance > Scripting > Script Execution Log**
2. Check "Usage" column for governance units
3. Identify slow operations

### Custom Logging

```javascript
var startTime = Date.now();

// Your code here

var duration = Date.now() - startTime;
log.audit('Performance', `Operation took ${duration}ms`);
```

## Best Practices Summary

1. **Batch operations** - Process in bulk when possible
2. **Cache aggressively** - Don't fetch the same data twice
3. **Use searches wisely** - Only select needed columns
4. **Optimize filters** - Use indexed fields
5. **Monitor governance** - Track unit usage
6. **Profile regularly** - Measure before optimizing
7. **Think asynchronous** - Use Map/Reduce for big jobs

## Practice Exercises

ðŸŽ¯ **Exercise 1**: Optimize a script that processes 10,000 records

ðŸŽ¯ **Exercise 2**: Implement caching for frequently accessed data

ðŸŽ¯ **Exercise 3**: Convert a slow User Event Script to Map/Reduce

## Next Steps

Learn advanced testing strategies to ensure your optimized code stays fast!
